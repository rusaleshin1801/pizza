"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = useHistoryTravel;
var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _useMemoizedFn = _interopRequireDefault(require("../useMemoizedFn"));
var _utils = require("../utils");
var dumpIndex = function dumpIndex(step, arr) {
  var index = step > 0 ? step - 1 // move forward
  : arr.length + step; // move backward
  if (index >= arr.length - 1) {
    index = arr.length - 1;
  }
  if (index < 0) {
    index = 0;
  }
  return index;
};
var split = function split(step, targetArr) {
  var index = dumpIndex(step, targetArr);
  return {
    _current: targetArr[index],
    _before: targetArr.slice(0, index),
    _after: targetArr.slice(index + 1)
  };
};
function useHistoryTravel(initialValue) {
  var maxLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var _useState = (0, _react.useState)({
      present: initialValue,
      past: [],
      future: []
    }),
    _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
    history = _useState2[0],
    setHistory = _useState2[1];
  var present = history.present,
    past = history.past,
    future = history.future;
  var initialValueRef = (0, _react.useRef)(initialValue);
  var reset = function reset() {
    var _initial = arguments.length > 0 ? arguments.length <= 0 ? undefined : arguments[0] : initialValueRef.current;
    initialValueRef.current = _initial;
    setHistory({
      present: _initial,
      future: [],
      past: []
    });
  };
  var updateValue = function updateValue(val) {
    var _past = [].concat((0, _toConsumableArray2["default"])(past), [present]);
    var maxLengthNum = (0, _utils.isNumber)(maxLength) ? maxLength : Number(maxLength);
    // maximum number of records exceeded
    if (maxLengthNum > 0 && _past.length > maxLengthNum) {
      //delete first
      _past.splice(0, 1);
    }
    setHistory({
      present: val,
      future: [],
      past: _past
    });
  };
  var _forward = function _forward() {
    var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    if (future.length === 0) {
      return;
    }
    var _split = split(step, future),
      _before = _split._before,
      _current = _split._current,
      _after = _split._after;
    setHistory({
      past: [].concat((0, _toConsumableArray2["default"])(past), [present], (0, _toConsumableArray2["default"])(_before)),
      present: _current,
      future: _after
    });
  };
  var _backward = function _backward() {
    var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    if (past.length === 0) {
      return;
    }
    var _split2 = split(step, past),
      _before = _split2._before,
      _current = _split2._current,
      _after = _split2._after;
    setHistory({
      past: _before,
      present: _current,
      future: [].concat((0, _toConsumableArray2["default"])(_after), [present], (0, _toConsumableArray2["default"])(future))
    });
  };
  var go = function go(step) {
    var stepNum = (0, _utils.isNumber)(step) ? step : Number(step);
    if (stepNum === 0) {
      return;
    }
    if (stepNum > 0) {
      return _forward(stepNum);
    }
    _backward(stepNum);
  };
  return {
    value: present,
    backLength: past.length,
    forwardLength: future.length,
    setValue: (0, _useMemoizedFn["default"])(updateValue),
    go: (0, _useMemoizedFn["default"])(go),
    back: (0, _useMemoizedFn["default"])(function () {
      go(-1);
    }),
    forward: (0, _useMemoizedFn["default"])(function () {
      go(1);
    }),
    reset: (0, _useMemoizedFn["default"])(reset)
  };
}