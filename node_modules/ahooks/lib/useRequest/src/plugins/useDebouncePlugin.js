"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _debounce = _interopRequireDefault(require("lodash/debounce"));
var _react = require("react");
var useDebouncePlugin = function useDebouncePlugin(fetchInstance, _ref) {
  var debounceWait = _ref.debounceWait,
    debounceLeading = _ref.debounceLeading,
    debounceTrailing = _ref.debounceTrailing,
    debounceMaxWait = _ref.debounceMaxWait;
  var debouncedRef = (0, _react.useRef)();
  var options = (0, _react.useMemo)(function () {
    var ret = {};
    if (debounceLeading !== undefined) {
      ret.leading = debounceLeading;
    }
    if (debounceTrailing !== undefined) {
      ret.trailing = debounceTrailing;
    }
    if (debounceMaxWait !== undefined) {
      ret.maxWait = debounceMaxWait;
    }
    return ret;
  }, [debounceLeading, debounceTrailing, debounceMaxWait]);
  (0, _react.useEffect)(function () {
    if (debounceWait) {
      var _originRunAsync = fetchInstance.runAsync.bind(fetchInstance);
      debouncedRef.current = (0, _debounce["default"])(function (callback) {
        callback();
      }, debounceWait, options);
      // debounce runAsync should be promise
      // https://github.com/lodash/lodash/issues/4400#issuecomment-834800398
      fetchInstance.runAsync = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return new Promise(function (resolve, reject) {
          var _a;
          (_a = debouncedRef.current) === null || _a === void 0 ? void 0 : _a.call(debouncedRef, function () {
            _originRunAsync.apply(void 0, args).then(resolve)["catch"](reject);
          });
        });
      };
      return function () {
        var _a;
        (_a = debouncedRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
        fetchInstance.runAsync = _originRunAsync;
      };
    }
  }, [debounceWait, options]);
  if (!debounceWait) {
    return {};
  }
  return {
    onCancel: function onCancel() {
      var _a;
      (_a = debouncedRef.current) === null || _a === void 0 ? void 0 : _a.cancel();
    }
  };
};
var _default = useDebouncePlugin;
exports["default"] = _default;