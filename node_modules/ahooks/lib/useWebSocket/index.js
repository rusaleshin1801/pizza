"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ReadyState = void 0;
exports["default"] = useWebSocket;
var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));
var _react = require("react");
var _useLatest = _interopRequireDefault(require("../useLatest"));
var _useMemoizedFn = _interopRequireDefault(require("../useMemoizedFn"));
var _useUnmount = _interopRequireDefault(require("../useUnmount"));
var ReadyState;
exports.ReadyState = ReadyState;
(function (ReadyState) {
  ReadyState[ReadyState["Connecting"] = 0] = "Connecting";
  ReadyState[ReadyState["Open"] = 1] = "Open";
  ReadyState[ReadyState["Closing"] = 2] = "Closing";
  ReadyState[ReadyState["Closed"] = 3] = "Closed";
})(ReadyState || (exports.ReadyState = ReadyState = {}));
function useWebSocket(socketUrl) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$reconnectLim = options.reconnectLimit,
    reconnectLimit = _options$reconnectLim === void 0 ? 3 : _options$reconnectLim,
    _options$reconnectInt = options.reconnectInterval,
    reconnectInterval = _options$reconnectInt === void 0 ? 3 * 1000 : _options$reconnectInt,
    _options$manual = options.manual,
    manual = _options$manual === void 0 ? false : _options$manual,
    onOpen = options.onOpen,
    onClose = options.onClose,
    onMessage = options.onMessage,
    onError = options.onError,
    protocols = options.protocols;
  var onOpenRef = (0, _useLatest["default"])(onOpen);
  var onCloseRef = (0, _useLatest["default"])(onClose);
  var onMessageRef = (0, _useLatest["default"])(onMessage);
  var onErrorRef = (0, _useLatest["default"])(onError);
  var reconnectTimesRef = (0, _react.useRef)(0);
  var reconnectTimerRef = (0, _react.useRef)();
  var websocketRef = (0, _react.useRef)();
  var unmountedRef = (0, _react.useRef)(false);
  var _useState = (0, _react.useState)(),
    _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
    latestMessage = _useState2[0],
    setLatestMessage = _useState2[1];
  var _useState3 = (0, _react.useState)(ReadyState.Closed),
    _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
    readyState = _useState4[0],
    setReadyState = _useState4[1];
  var reconnect = function reconnect() {
    var _a;
    if (reconnectTimesRef.current < reconnectLimit && ((_a = websocketRef.current) === null || _a === void 0 ? void 0 : _a.readyState) !== ReadyState.Open) {
      if (reconnectTimerRef.current) {
        clearTimeout(reconnectTimerRef.current);
      }
      reconnectTimerRef.current = setTimeout(function () {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        connectWs();
        reconnectTimesRef.current++;
      }, reconnectInterval);
    }
  };
  var connectWs = function connectWs() {
    if (reconnectTimerRef.current) {
      clearTimeout(reconnectTimerRef.current);
    }
    if (websocketRef.current) {
      websocketRef.current.close();
    }
    var ws = new WebSocket(socketUrl, protocols);
    setReadyState(ReadyState.Connecting);
    ws.onerror = function (event) {
      var _a;
      if (unmountedRef.current) {
        return;
      }
      reconnect();
      (_a = onErrorRef.current) === null || _a === void 0 ? void 0 : _a.call(onErrorRef, event, ws);
      setReadyState(ws.readyState || ReadyState.Closed);
    };
    ws.onopen = function (event) {
      var _a;
      if (unmountedRef.current) {
        return;
      }
      (_a = onOpenRef.current) === null || _a === void 0 ? void 0 : _a.call(onOpenRef, event, ws);
      reconnectTimesRef.current = 0;
      setReadyState(ws.readyState || ReadyState.Open);
    };
    ws.onmessage = function (message) {
      var _a;
      if (unmountedRef.current) {
        return;
      }
      (_a = onMessageRef.current) === null || _a === void 0 ? void 0 : _a.call(onMessageRef, message, ws);
      setLatestMessage(message);
    };
    ws.onclose = function (event) {
      var _a;
      if (unmountedRef.current) {
        return;
      }
      reconnect();
      (_a = onCloseRef.current) === null || _a === void 0 ? void 0 : _a.call(onCloseRef, event, ws);
      setReadyState(ws.readyState || ReadyState.Closed);
    };
    websocketRef.current = ws;
  };
  var sendMessage = function sendMessage(message) {
    var _a;
    if (readyState === ReadyState.Open) {
      (_a = websocketRef.current) === null || _a === void 0 ? void 0 : _a.send(message);
    } else {
      throw new Error('WebSocket disconnected');
    }
  };
  var connect = function connect() {
    reconnectTimesRef.current = 0;
    connectWs();
  };
  var disconnect = function disconnect() {
    var _a;
    if (reconnectTimerRef.current) {
      clearTimeout(reconnectTimerRef.current);
    }
    reconnectTimesRef.current = reconnectLimit;
    (_a = websocketRef.current) === null || _a === void 0 ? void 0 : _a.close();
  };
  (0, _react.useEffect)(function () {
    if (!manual) {
      connect();
    }
  }, [socketUrl, manual]);
  (0, _useUnmount["default"])(function () {
    unmountedRef.current = true;
    disconnect();
  });
  return {
    latestMessage: latestMessage,
    sendMessage: (0, _useMemoizedFn["default"])(sendMessage),
    connect: (0, _useMemoizedFn["default"])(connect),
    disconnect: (0, _useMemoizedFn["default"])(disconnect),
    readyState: readyState,
    webSocketIns: websocketRef.current
  };
}