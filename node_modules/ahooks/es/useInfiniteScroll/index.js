import { __awaiter } from "tslib";
import { useMemo, useState } from 'react';
import useEventListener from '../useEventListener';
import useMemoizedFn from '../useMemoizedFn';
import useRequest from '../useRequest';
import useUpdateEffect from '../useUpdateEffect';
import { getTargetElement } from '../utils/domTarget';
import { getClientHeight, getScrollHeight, getScrollTop } from '../utils/rect';
const useInfiniteScroll = (service, options = {}) => {
  const {
    target,
    isNoMore,
    threshold = 100,
    reloadDeps = [],
    manual,
    onBefore,
    onSuccess,
    onError,
    onFinally
  } = options;
  const [finalData, setFinalData] = useState();
  const [loadingMore, setLoadingMore] = useState(false);
  const noMore = useMemo(() => {
    if (!isNoMore) return false;
    return isNoMore(finalData);
  }, [finalData]);
  const {
    loading,
    run,
    runAsync,
    cancel
  } = useRequest(lastData => __awaiter(void 0, void 0, void 0, function* () {
    const currentData = yield service(lastData);
    if (!lastData) {
      setFinalData(currentData);
    } else {
      setFinalData(Object.assign(Object.assign({}, currentData), {
        // @ts-ignore
        list: [...lastData.list, ...currentData.list]
      }));
    }
    return currentData;
  }), {
    manual,
    onFinally: (_, d, e) => {
      setLoadingMore(false);
      onFinally === null || onFinally === void 0 ? void 0 : onFinally(d, e);
    },
    onBefore: () => onBefore === null || onBefore === void 0 ? void 0 : onBefore(),
    onSuccess: d => {
      setTimeout(() => {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        scrollMethod();
      });
      onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(d);
    },
    onError: e => onError === null || onError === void 0 ? void 0 : onError(e)
  });
  const loadMore = () => {
    if (noMore) return;
    setLoadingMore(true);
    run(finalData);
  };
  const loadMoreAsync = () => {
    if (noMore) return Promise.reject();
    setLoadingMore(true);
    return runAsync(finalData);
  };
  const reload = () => run();
  const reloadAsync = () => runAsync();
  const scrollMethod = () => {
    const el = getTargetElement(target);
    if (!el) {
      return;
    }
    const scrollTop = getScrollTop(el);
    const scrollHeight = getScrollHeight(el);
    const clientHeight = getClientHeight(el);
    if (scrollHeight - scrollTop <= clientHeight + threshold) {
      loadMore();
    }
  };
  useEventListener('scroll', () => {
    if (loading || loadingMore) {
      return;
    }
    scrollMethod();
  }, {
    target
  });
  useUpdateEffect(() => {
    run();
  }, [...reloadDeps]);
  return {
    data: finalData,
    loading: !loadingMore && loading,
    loadingMore,
    noMore,
    loadMore: useMemoizedFn(loadMore),
    loadMoreAsync: useMemoizedFn(loadMoreAsync),
    reload: useMemoizedFn(reload),
    reloadAsync: useMemoizedFn(reloadAsync),
    mutate: setFinalData,
    cancel
  };
};
export default useInfiniteScroll;